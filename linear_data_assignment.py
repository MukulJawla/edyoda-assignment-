# -*- coding: utf-8 -*-
"""Linear data assignment

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19FkyzNMc9BwAU4jA_lBeTzf7d0hpqQIt
"""

#Q1. Write a program to find all pairs of an integer array whose sum is equal to a given number?
def sum_num(arr, n, sum):
  for i in range(0, n ):
        for j in range(i + 1, n ):
            if (arr[i] + arr[j] == sum):
                print("(", arr[i],", ", arr[j],")", sep = "")
            
arr = [1, 5, 7, -1, 5]
n = len(arr)
sum = 6
sum_num(arr, n, sum)

#Q2. Write a program to reverse an array in place? In place means you cannot create a new array. You have to update the original array.
def reverseList(A,start, end):
    while start < end:
        A[start], A[end] = A[end], A[start]
        start += 1
        end -= 1
A = [1, 2, 3, 4, 5, 6]
end =len(A)-1
print(A)
reverseList(A, 0,end )
print("Reversed list is")
print(A)

#Q3. Write a program to check if two strings are a rotation of each other?
def checkRotation(s1, s2): 
    temp = ''    
    if len(s1) != len(s2): 
        return False 
    temp = s1 + s1    
    if s2 in temp: 
        return True 
    else: 
        return False
string1 = "HELLO"
string2 = "LOHEa"
if checkRotation(string1, string2): 
    print("Given Strings are rotations of each other.")
else: 
    print("Given Strings are not rotations of each other.")

#Q4. Write a program to print the first non-repeated character from a string?
string = "mukulm"
index =0
for i in string:
    if string.count(i) == 1:
      print(i)
      break

#Q5. Read about the Tower of Hanoi algorithm. Write a program to implement 
def TowerOfHanoi(n, rodA, rodB, rodC):
    if n == 0:
        return
    TowerOfHanoi(n-1, rodA, rodC, rodA)
    print("Move disk", n, "from rod", rodA, "to rod", rodB)
    TowerOfHanoi(n-1, rodC, rodB, rodA)

N = 3
 
# A, C, B are the name of rods
TowerOfHanoi(N, 'A', 'C', 'B')

#Q6. Read about infix, prefix, and postfix expressions. Write a program to convert postfix to prefix expression
s = "*-A/BC-/AKL" 
stack = [] 
operators = set(['+', '-', '*', '/', '^'])
s = s[::-1]
for i in s:
    if i in operators:
        a = stack.pop()
        b = stack.pop()
        temp = a+b+i
        stack.append(temp)
    else:
        stack.append(i)
print(*stack)

#07Write a program to convert prefix expression to infix expression
def prefixToInfix(prefix):
    stack = []
    i = len(prefix) - 1
    while i >= 0:
        if not isOperator(prefix[i]):
            stack.append(prefix[i])
            i -= 1
        else:
          str = "(" + stack.pop() + prefix[i] + stack.pop() + ")"
          stack.append(str)
          i -= 1 
    return stack.pop()
def isOperator(c):
    if c == "*" or c == "+" or c == "-" or c == "/" or c == "^" or c == "(" or c == ")":
        return True
    else:
        return False
str = "*-A/BC-/AKL"
print(prefixToInfix(str))

#08Write a program to check if all the brackets are closed in a given code snippet.
def areBracketsBalanced(expr):
    stack = []
    for char in expr:
        if char in ["(", "{", "["]:
            stack.append(char)
        else:
          if not stack:
                return False
          current_char = stack.pop()
          if current_char == '(':
                if char != ")":
                    return False
          if current_char == '{':
                if char != "}":
                    return False
          if current_char == '[':
                if char != "]":
                    return False
    if stack:
        return False
    return True
if __name__ == "__main__":
    expr = "{()}[]"
    if areBracketsBalanced(expr):
        print("Balanced")
    else:
        print("Not Balanced")

#09Write a program to reverse a stack
class Stack:
    def __init__(self):
        self.Elements = []
    def push(self, value):
        self.Elements.append(value)
    def pop(self):
        return self.Elements.pop()
    def empty(self):
        return self.Elements == []
    def show(self):
        for value in reversed(self.Elements):
            print(value)
def BottomInsert(s, value):
    if s.empty():
        s.push(value)
    else:
        popped = s.pop()
        BottomInsert(s, value)
        s.push(popped)
def Reverse(s):
    if s.empty():
        pass
    else:
        popped = s.pop()
        Reverse(s)
        BottomInsert(s, popped)
stk = Stack()
 
stk.push(1)
stk.push(2)
stk.push(3)
stk.push(4)
stk.push(5)
 
print("Original Stack")
stk.show()
 
print("\nStack after Reversing")
Reverse(stk)
stk.show()

#10Write a program to find the smallest number using a stack.
class MinStack(object):
   min=float('inf')
   def __init__(self):
      self.min=float('inf')
      self.stack = []
   def push(self, x):
      if x<=self.min:
         self.stack.append(self.min)
         self.min = x
      self.stack.append(x)
   def pop(self):
      t = self.stack[-1]
      self.stack.pop()
      if self.min == t:
         self.min = self.stack[-1]
         self.stack.pop()
   def getMin(self):
      return self.min
m = MinStack()
m.push(-2)
m.push(0)
m.push(-3)
print(m.getMin())

















































